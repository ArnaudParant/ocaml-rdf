<!DOCTYPE HTML>
<html>
<head>
<title>OCaml-RDF : OCaml-RDF reference documentation : Rdf_sparql_vis.T</title><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="http://zoggy.github.io/ocaml-rdf/style.css" rel="stylesheet" type="text/css"/>
<rssfeed></rssfeed>
</head><body>
<div id="page">
<div class="navbar navbar-fixed-top">
<div class="navbar-inner">
<div class="container">

  <div class="nav-collapse">
  <ul class="nav">
    <li class="&lt;navbar-home/&gt;"><a href="http://zoggy.github.io/ocaml-rdf">OCaml-RDF</a></li>
    <li class="&lt;navbar-download/&gt;"><a href="http://zoggy.github.io/ocaml-rdf/download.html">Download</a></li>
    <li class="active"><a href="http://zoggy.github.io/ocaml-rdf/doc.html">Documentation</a></li>
    <li class="&lt;navbar-blog/&gt;"><a href="http://zoggy.github.io/ocaml-rdf/blog.html">Blog</a></li>
    <li class="&lt;navbar-about/&gt;"><a href="http://zoggy.github.io/ocaml-rdf/about.html">?</a></li>
  </ul>
  </div>
  <div class="nav pull-right">

  </div>
</div>
</div>
</div>

<div id="header">


</div>
<span></span>

<div class="ocamldoc-page">
<code class="code"><span class="keyword">sig</span><br/>
  <span class="keyword">module</span> <span class="constructor">OrderedString</span> :<br/>
    <span class="keyword">sig</span> <span class="keyword">type</span> t = string <span class="keyword">val</span> compare : <span class="constructor">String</span>.t <span class="keywordsign">-&gt;</span> <span class="constructor">String</span>.t <span class="keywordsign">-&gt;</span> int <span class="keyword">end</span><br/>
  <span class="keyword">module</span> <span class="constructor">SSet</span> :<br/>
    <span class="keyword">sig</span><br/>
      <span class="keyword">type</span> elt = string<br/>
      <span class="keyword">type</span> t = <span class="constructor">Rdf_types</span>.<span class="constructor">SSet</span>.t<br/>
      <span class="keyword">val</span> empty : t<br/>
      <span class="keyword">val</span> is_empty : t <span class="keywordsign">-&gt;</span> bool<br/>
      <span class="keyword">val</span> mem : elt <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> bool<br/>
      <span class="keyword">val</span> add : elt <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> t<br/>
      <span class="keyword">val</span> singleton : elt <span class="keywordsign">-&gt;</span> t<br/>
      <span class="keyword">val</span> remove : elt <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> t<br/>
      <span class="keyword">val</span> union : t <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> t<br/>
      <span class="keyword">val</span> inter : t <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> t<br/>
      <span class="keyword">val</span> diff : t <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> t<br/>
      <span class="keyword">val</span> compare : t <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> int<br/>
      <span class="keyword">val</span> equal : t <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> bool<br/>
      <span class="keyword">val</span> subset : t <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> bool<br/>
      <span class="keyword">val</span> iter : (elt <span class="keywordsign">-&gt;</span> unit) <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> unit<br/>
      <span class="keyword">val</span> fold : (elt <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a) <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a<br/>
      <span class="keyword">val</span> for_all : (elt <span class="keywordsign">-&gt;</span> bool) <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> bool<br/>
      <span class="keyword">val</span> exists : (elt <span class="keywordsign">-&gt;</span> bool) <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> bool<br/>
      <span class="keyword">val</span> filter : (elt <span class="keywordsign">-&gt;</span> bool) <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> t<br/>
      <span class="keyword">val</span> partition : (elt <span class="keywordsign">-&gt;</span> bool) <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> t * t<br/>
      <span class="keyword">val</span> cardinal : t <span class="keywordsign">-&gt;</span> int<br/>
      <span class="keyword">val</span> elements : t <span class="keywordsign">-&gt;</span> elt list<br/>
      <span class="keyword">val</span> min_elt : t <span class="keywordsign">-&gt;</span> elt<br/>
      <span class="keyword">val</span> max_elt : t <span class="keywordsign">-&gt;</span> elt<br/>
      <span class="keyword">val</span> choose : t <span class="keywordsign">-&gt;</span> elt<br/>
      <span class="keyword">val</span> split : elt <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> t * bool * t<br/>
      <span class="keyword">val</span> find : elt <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> elt<br/>
    <span class="keyword">end</span><br/>
  <span class="keyword">module</span> <span class="constructor">SMap</span> :<br/>
    <span class="keyword">sig</span><br/>
      <span class="keyword">type</span> key = string<br/>
      <span class="keyword">type</span> <span class="keywordsign">'</span>a t = <span class="keywordsign">'</span>a <span class="constructor">Rdf_types</span>.<span class="constructor">SMap</span>.t<br/>
      <span class="keyword">val</span> empty : <span class="keywordsign">'</span>a t<br/>
      <span class="keyword">val</span> is_empty : <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> bool<br/>
      <span class="keyword">val</span> mem : key <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> bool<br/>
      <span class="keyword">val</span> add : key <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t<br/>
      <span class="keyword">val</span> singleton : key <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t<br/>
      <span class="keyword">val</span> remove : key <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t<br/>
      <span class="keyword">val</span> merge :<br/>
        (key <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a option <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>b option <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>c option) <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>b t <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>c t<br/>
      <span class="keyword">val</span> compare : (<span class="keywordsign">'</span>a <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a <span class="keywordsign">-&gt;</span> int) <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> int<br/>
      <span class="keyword">val</span> equal : (<span class="keywordsign">'</span>a <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a <span class="keywordsign">-&gt;</span> bool) <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> bool<br/>
      <span class="keyword">val</span> iter : (key <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a <span class="keywordsign">-&gt;</span> unit) <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> unit<br/>
      <span class="keyword">val</span> fold : (key <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>b <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>b) <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>b <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>b<br/>
      <span class="keyword">val</span> for_all : (key <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a <span class="keywordsign">-&gt;</span> bool) <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> bool<br/>
      <span class="keyword">val</span> exists : (key <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a <span class="keywordsign">-&gt;</span> bool) <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> bool<br/>
      <span class="keyword">val</span> filter : (key <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a <span class="keywordsign">-&gt;</span> bool) <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t<br/>
      <span class="keyword">val</span> partition : (key <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a <span class="keywordsign">-&gt;</span> bool) <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t * <span class="keywordsign">'</span>a t<br/>
      <span class="keyword">val</span> cardinal : <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> int<br/>
      <span class="keyword">val</span> bindings : <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> (key * <span class="keywordsign">'</span>a) list<br/>
      <span class="keyword">val</span> min_binding : <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> key * <span class="keywordsign">'</span>a<br/>
      <span class="keyword">val</span> max_binding : <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> key * <span class="keywordsign">'</span>a<br/>
      <span class="keyword">val</span> choose : <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> key * <span class="keywordsign">'</span>a<br/>
      <span class="keyword">val</span> split : key <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t * <span class="keywordsign">'</span>a option * <span class="keywordsign">'</span>a t<br/>
      <span class="keyword">val</span> find : key <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a<br/>
      <span class="keyword">val</span> map : (<span class="keywordsign">'</span>a <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>b) <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>b t<br/>
      <span class="keyword">val</span> mapi : (key <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>b) <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>b t<br/>
    <span class="keyword">end</span><br/>
  <span class="keyword">type</span> loc =<br/>
    <span class="constructor">Rdf_loc</span>.loc = {<br/>
    loc_start : <span class="constructor">Lexing</span>.position;<br/>
    loc_end : <span class="constructor">Lexing</span>.position;<br/>
  }<br/>
  <span class="keyword">type</span> pname_ns =<br/>
    <span class="constructor">Rdf_sparql_types</span>.pname_ns = {<br/>
    pname_ns_loc : loc;<br/>
    pname_ns_name : string;<br/>
  }<br/>
  <span class="keyword">type</span> pname_local =<br/>
    <span class="constructor">Rdf_sparql_types</span>.pname_local = {<br/>
    pname_local_loc : loc;<br/>
    pname_local_name : string;<br/>
  }<br/>
  <span class="keyword">type</span> var = <span class="constructor">Rdf_sparql_types</span>.var = { var_loc : loc; var_name : string; }<br/>
  <span class="keyword">type</span> iriref =<br/>
    <span class="constructor">Rdf_sparql_types</span>.iriref = {<br/>
    ir_loc : loc;<br/>
    ir_iri : <span class="constructor">Rdf_iri</span>.iri;<br/>
  }<br/>
  <span class="keyword">type</span> prefixed_name =<br/>
    <span class="constructor">Rdf_sparql_types</span>.prefixed_name = {<br/>
    pname_loc : loc;<br/>
    pname_ns : pname_ns;<br/>
    pname_local : pname_local option;<br/>
  }<br/>
  <span class="keyword">type</span> rel_iri =<br/>
    <span class="constructor">Rdf_sparql_types</span>.rel_iri = {<br/>
    reliri_loc : loc;<br/>
    reliri : string;<br/>
  }<br/>
  <span class="keyword">type</span> iri =<br/>
    <span class="constructor">Rdf_sparql_types</span>.iri =<br/>
      <span class="constructor">Iriref</span> <span class="keyword">of</span> iriref<br/>
    <span class="keywordsign">|</span> <span class="constructor">PrefixedName</span> <span class="keyword">of</span> prefixed_name<br/>
    <span class="keywordsign">|</span> <span class="constructor">Reliri</span> <span class="keyword">of</span> rel_iri<br/>
  <span class="keyword">type</span> prefix_decl = pname_ns * rel_iri<br/>
  <span class="keyword">type</span> query_prolog_decl =<br/>
    <span class="constructor">Rdf_sparql_types</span>.query_prolog_decl =<br/>
      <span class="constructor">BaseDecl</span> <span class="keyword">of</span> rel_iri<br/>
    <span class="keywordsign">|</span> <span class="constructor">PrefixDecl</span> <span class="keyword">of</span> prefix_decl<br/>
  <span class="keyword">type</span> query_prolog = query_prolog_decl list<br/>
  <span class="keyword">type</span> rdf_literal =<br/>
    <span class="constructor">Rdf_sparql_types</span>.rdf_literal = {<br/>
    rdf_lit_loc : loc;<br/>
    rdf_lit : <span class="constructor">Rdf_term</span>.literal;<br/>
    rdf_lit_type : iri option;<br/>
  }<br/>
  <span class="keyword">type</span> data_block_value =<br/>
    <span class="constructor">Rdf_sparql_types</span>.data_block_value =<br/>
      <span class="constructor">DataBlockValueIri</span> <span class="keyword">of</span> iri<br/>
    <span class="keywordsign">|</span> <span class="constructor">DataBlockValueRdf</span> <span class="keyword">of</span> rdf_literal<br/>
    <span class="keywordsign">|</span> <span class="constructor">DataBlockValueNumeric</span> <span class="keyword">of</span> rdf_literal<br/>
    <span class="keywordsign">|</span> <span class="constructor">DataBlockValueBoolean</span> <span class="keyword">of</span> rdf_literal<br/>
    <span class="keywordsign">|</span> <span class="constructor">DataBlockValueUndef</span><br/>
  <span class="keyword">type</span> data_full_block_value =<br/>
    <span class="constructor">Rdf_sparql_types</span>.data_full_block_value =<br/>
      <span class="constructor">Nil</span><br/>
    <span class="keywordsign">|</span> <span class="constructor">Value</span> <span class="keyword">of</span> data_block_value list<br/>
  <span class="keyword">type</span> inline_data_one_var =<br/>
    <span class="constructor">Rdf_sparql_types</span>.inline_data_one_var = {<br/>
    idov_loc : loc;<br/>
    idov_var : var;<br/>
    idov_data : data_block_value list;<br/>
  }<br/>
  <span class="keyword">type</span> inline_data_full =<br/>
    <span class="constructor">Rdf_sparql_types</span>.inline_data_full = {<br/>
    idf_loc : loc;<br/>
    idf_vars : var list;<br/>
    idf_values : data_full_block_value list;<br/>
  }<br/>
  <span class="keyword">type</span> datablock =<br/>
    <span class="constructor">Rdf_sparql_types</span>.datablock =<br/>
      <span class="constructor">InLineDataOneVar</span> <span class="keyword">of</span> inline_data_one_var<br/>
    <span class="keywordsign">|</span> <span class="constructor">InLineDataFull</span> <span class="keyword">of</span> inline_data_full<br/>
  <span class="keyword">type</span> values_clause = datablock option<br/>
  <span class="keyword">type</span> path_mod =<br/>
    <span class="constructor">Rdf_sparql_types</span>.path_mod =<br/>
      <span class="constructor">ModOptional</span><br/>
    <span class="keywordsign">|</span> <span class="constructor">ModList</span><br/>
    <span class="keywordsign">|</span> <span class="constructor">ModOneOrMore</span><br/>
  <span class="keyword">type</span> var_or_iri = <span class="constructor">Rdf_sparql_types</span>.var_or_iri = <span class="constructor">VIVar</span> <span class="keyword">of</span> var <span class="keywordsign">|</span> <span class="constructor">VIIri</span> <span class="keyword">of</span> iri<br/>
  <span class="keyword">type</span> blank_node =<br/>
    <span class="constructor">Rdf_sparql_types</span>.blank_node = {<br/>
    bnode_loc : loc;<br/>
    bnode_label : string option;<br/>
  }<br/>
  <span class="keyword">type</span> select_clause_flag =<br/>
    <span class="constructor">Rdf_sparql_types</span>.select_clause_flag =<br/>
      <span class="constructor">Distinct</span><br/>
    <span class="keywordsign">|</span> <span class="constructor">Reduced</span><br/>
  <span class="keyword">type</span> select_var =<br/>
    <span class="constructor">Rdf_sparql_types</span>.select_var = {<br/>
    sel_var_loc : loc;<br/>
    sel_var_expr : expression option;<br/>
    sel_var : var;<br/>
  }<br/>
  <span class="keyword">and</span> select_vars =<br/>
    <span class="constructor">Rdf_sparql_types</span>.select_vars =<br/>
      <span class="constructor">SelectAll</span><br/>
    <span class="keywordsign">|</span> <span class="constructor">SelectVars</span> <span class="keyword">of</span> select_var list<br/>
  <span class="keyword">and</span> select_clause =<br/>
    <span class="constructor">Rdf_sparql_types</span>.select_clause = {<br/>
    sel_flag : select_clause_flag option;<br/>
    sel_vars : select_vars;<br/>
  }<br/>
  <span class="keyword">and</span> source_selector = iri<br/>
  <span class="keyword">and</span> dataset_clause =<br/>
    <span class="constructor">Rdf_sparql_types</span>.dataset_clause =<br/>
      <span class="constructor">DefaultGraphClause</span> <span class="keyword">of</span> source_selector<br/>
    <span class="keywordsign">|</span> <span class="constructor">NamedGraphClause</span> <span class="keyword">of</span> source_selector<br/>
  <span class="keyword">and</span> arg_list =<br/>
    <span class="constructor">Rdf_sparql_types</span>.arg_list = {<br/>
    argl_loc : loc;<br/>
    argl_distinct : bool;<br/>
    argl : expression list;<br/>
  }<br/>
  <span class="keyword">and</span> function_call =<br/>
    <span class="constructor">Rdf_sparql_types</span>.function_call = {<br/>
    func_loc : loc;<br/>
    func_iri : iri;<br/>
    func_args : arg_list;<br/>
  }<br/>
  <span class="keyword">and</span> binary_op =<br/>
    <span class="constructor">Rdf_sparql_types</span>.binary_op =<br/>
      <span class="constructor">EPlus</span><br/>
    <span class="keywordsign">|</span> <span class="constructor">EMinus</span><br/>
    <span class="keywordsign">|</span> <span class="constructor">EMult</span><br/>
    <span class="keywordsign">|</span> <span class="constructor">EDiv</span><br/>
    <span class="keywordsign">|</span> <span class="constructor">EEqual</span><br/>
    <span class="keywordsign">|</span> <span class="constructor">ENotEqual</span><br/>
    <span class="keywordsign">|</span> <span class="constructor">ELt</span><br/>
    <span class="keywordsign">|</span> <span class="constructor">EGt</span><br/>
    <span class="keywordsign">|</span> <span class="constructor">ELte</span><br/>
    <span class="keywordsign">|</span> <span class="constructor">EGte</span><br/>
    <span class="keywordsign">|</span> <span class="constructor">EOr</span><br/>
    <span class="keywordsign">|</span> <span class="constructor">EAnd</span><br/>
  <span class="keyword">and</span> expr =<br/>
    <span class="constructor">Rdf_sparql_types</span>.expr =<br/>
      <span class="constructor">EVar</span> <span class="keyword">of</span> var<br/>
    <span class="keywordsign">|</span> <span class="constructor">EIri</span> <span class="keyword">of</span> iri<br/>
    <span class="keywordsign">|</span> <span class="constructor">EBin</span> <span class="keyword">of</span> expression * binary_op * expression<br/>
    <span class="keywordsign">|</span> <span class="constructor">ENot</span> <span class="keyword">of</span> expression<br/>
    <span class="keywordsign">|</span> <span class="constructor">EUMinus</span> <span class="keyword">of</span> expression<br/>
    <span class="keywordsign">|</span> <span class="constructor">EBic</span> <span class="keyword">of</span> built_in_call<br/>
    <span class="keywordsign">|</span> <span class="constructor">EFuncall</span> <span class="keyword">of</span> function_call<br/>
    <span class="keywordsign">|</span> <span class="constructor">ELit</span> <span class="keyword">of</span> rdf_literal<br/>
    <span class="keywordsign">|</span> <span class="constructor">ENumeric</span> <span class="keyword">of</span> rdf_literal<br/>
    <span class="keywordsign">|</span> <span class="constructor">EBoolean</span> <span class="keyword">of</span> rdf_literal<br/>
    <span class="keywordsign">|</span> <span class="constructor">EIn</span> <span class="keyword">of</span> expression * expression list<br/>
    <span class="keywordsign">|</span> <span class="constructor">ENotIn</span> <span class="keyword">of</span> expression * expression list<br/>
  <span class="keyword">and</span> expression =<br/>
    <span class="constructor">Rdf_sparql_types</span>.expression = {<br/>
    expr_loc : loc;<br/>
    expr : expr;<br/>
  }<br/>
  <span class="keyword">and</span> built_in_call =<br/>
    <span class="constructor">Rdf_sparql_types</span>.built_in_call =<br/>
      <span class="constructor">Bic_agg</span> <span class="keyword">of</span> aggregate<br/>
    <span class="keywordsign">|</span> <span class="constructor">Bic_fun</span> <span class="keyword">of</span> string * expression list<br/>
    <span class="keywordsign">|</span> <span class="constructor">Bic_BOUND</span> <span class="keyword">of</span> var<br/>
    <span class="keywordsign">|</span> <span class="constructor">Bic_EXISTS</span> <span class="keyword">of</span> group_graph_pattern<br/>
    <span class="keywordsign">|</span> <span class="constructor">Bic_NOTEXISTS</span> <span class="keyword">of</span> group_graph_pattern<br/>
  <span class="keyword">and</span> aggregate =<br/>
    <span class="constructor">Rdf_sparql_types</span>.aggregate =<br/>
      <span class="constructor">Bic_COUNT</span> <span class="keyword">of</span> bool * expression option<br/>
    <span class="keywordsign">|</span> <span class="constructor">Bic_SUM</span> <span class="keyword">of</span> bool * expression<br/>
    <span class="keywordsign">|</span> <span class="constructor">Bic_MIN</span> <span class="keyword">of</span> bool * expression<br/>
    <span class="keywordsign">|</span> <span class="constructor">Bic_MAX</span> <span class="keyword">of</span> bool * expression<br/>
    <span class="keywordsign">|</span> <span class="constructor">Bic_AVG</span> <span class="keyword">of</span> bool * expression<br/>
    <span class="keywordsign">|</span> <span class="constructor">Bic_SAMPLE</span> <span class="keyword">of</span> bool * expression<br/>
    <span class="keywordsign">|</span> <span class="constructor">Bic_GROUP_CONCAT</span> <span class="keyword">of</span> bool * expression * string option<br/>
  <span class="keyword">and</span> group_var =<br/>
    <span class="constructor">Rdf_sparql_types</span>.group_var = {<br/>
    grpvar_loc : loc;<br/>
    grpvar_expr : expression option;<br/>
    grpvar : var option;<br/>
  }<br/>
  <span class="keyword">and</span> group_condition =<br/>
    <span class="constructor">Rdf_sparql_types</span>.group_condition =<br/>
      <span class="constructor">GroupBuiltInCall</span> <span class="keyword">of</span> built_in_call<br/>
    <span class="keywordsign">|</span> <span class="constructor">GroupFunctionCall</span> <span class="keyword">of</span> function_call<br/>
    <span class="keywordsign">|</span> <span class="constructor">GroupVar</span> <span class="keyword">of</span> group_var<br/>
  <span class="keyword">and</span> constraint_ =<br/>
    <span class="constructor">Rdf_sparql_types</span>.constraint_ =<br/>
      <span class="constructor">ConstrBuiltInCall</span> <span class="keyword">of</span> built_in_call<br/>
    <span class="keywordsign">|</span> <span class="constructor">ConstrFunctionCall</span> <span class="keyword">of</span> function_call<br/>
    <span class="keywordsign">|</span> <span class="constructor">ConstrExpr</span> <span class="keyword">of</span> expression<br/>
  <span class="keyword">and</span> having_condition = constraint_<br/>
  <span class="keyword">and</span> order_condition =<br/>
    <span class="constructor">Rdf_sparql_types</span>.order_condition =<br/>
      <span class="constructor">OrderAsc</span> <span class="keyword">of</span> expression<br/>
    <span class="keywordsign">|</span> <span class="constructor">OrderDesc</span> <span class="keyword">of</span> expression<br/>
    <span class="keywordsign">|</span> <span class="constructor">OrderConstr</span> <span class="keyword">of</span> constraint_<br/>
    <span class="keywordsign">|</span> <span class="constructor">OrderVar</span> <span class="keyword">of</span> var<br/>
  <span class="keyword">and</span> limit_offset_clause =<br/>
    <span class="constructor">Rdf_sparql_types</span>.limit_offset_clause = {<br/>
    limoff_loc : loc;<br/>
    limoff_offset : int option;<br/>
    limoff_limit : int option;<br/>
  }<br/>
  <span class="keyword">and</span> solution_modifier =<br/>
    <span class="constructor">Rdf_sparql_types</span>.solution_modifier = {<br/>
    solmod_loc : loc;<br/>
    solmod_group : group_condition list;<br/>
    solmod_having : having_condition list;<br/>
    solmod_order : order_condition list option;<br/>
    solmod_limoff : limit_offset_clause option;<br/>
  }<br/>
  <span class="keyword">and</span> bind =<br/>
    <span class="constructor">Rdf_sparql_types</span>.bind = {<br/>
    bind_loc : loc;<br/>
    bind_expr : expression;<br/>
    bind_var : var;<br/>
  }<br/>
  <span class="keyword">and</span> service_graph_pattern =<br/>
    <span class="constructor">Rdf_sparql_types</span>.service_graph_pattern = {<br/>
    servgp_loc : loc;<br/>
    servgp_silent : bool;<br/>
    servgp_name : var_or_iri;<br/>
    servgp_pat : group_graph_pattern;<br/>
  }<br/>
  <span class="keyword">and</span> graph_graph_pattern =<br/>
    <span class="constructor">Rdf_sparql_types</span>.graph_graph_pattern = {<br/>
    graphgp_loc : loc;<br/>
    graphgp_name : var_or_iri;<br/>
    graphgp_pat : group_graph_pattern;<br/>
  }<br/>
  <span class="keyword">and</span> graph_pattern_elt =<br/>
    <span class="constructor">Rdf_sparql_types</span>.graph_pattern_elt =<br/>
      <span class="constructor">Triples</span> <span class="keyword">of</span> triples_block<br/>
    <span class="keywordsign">|</span> <span class="constructor">Union</span> <span class="keyword">of</span> group_graph_pattern list<br/>
    <span class="keywordsign">|</span> <span class="constructor">Optional</span> <span class="keyword">of</span> group_graph_pattern<br/>
    <span class="keywordsign">|</span> <span class="constructor">Minus</span> <span class="keyword">of</span> group_graph_pattern<br/>
    <span class="keywordsign">|</span> <span class="constructor">GGP</span> <span class="keyword">of</span> graph_graph_pattern<br/>
    <span class="keywordsign">|</span> <span class="constructor">Service</span> <span class="keyword">of</span> service_graph_pattern<br/>
    <span class="keywordsign">|</span> <span class="constructor">Filter</span> <span class="keyword">of</span> constraint_<br/>
    <span class="keywordsign">|</span> <span class="constructor">Bind</span> <span class="keyword">of</span> bind<br/>
    <span class="keywordsign">|</span> <span class="constructor">InlineData</span> <span class="keyword">of</span> datablock<br/>
  <span class="keyword">and</span> graph_term =<br/>
    <span class="constructor">Rdf_sparql_types</span>.graph_term =<br/>
      <span class="constructor">GraphTermIri</span> <span class="keyword">of</span> iri<br/>
    <span class="keywordsign">|</span> <span class="constructor">GraphTermLit</span> <span class="keyword">of</span> rdf_literal<br/>
    <span class="keywordsign">|</span> <span class="constructor">GraphTermNumeric</span> <span class="keyword">of</span> rdf_literal<br/>
    <span class="keywordsign">|</span> <span class="constructor">GraphTermBoolean</span> <span class="keyword">of</span> rdf_literal<br/>
    <span class="keywordsign">|</span> <span class="constructor">GraphTermBlank</span> <span class="keyword">of</span> blank_node<br/>
    <span class="keywordsign">|</span> <span class="constructor">GraphTermNil</span><br/>
    <span class="keywordsign">|</span> <span class="constructor">GraphTermNode</span> <span class="keyword">of</span> <span class="constructor">Rdf_term</span>.term<br/>
  <span class="keyword">and</span> var_or_term =<br/>
    <span class="constructor">Rdf_sparql_types</span>.var_or_term =<br/>
      <span class="constructor">Var</span> <span class="keyword">of</span> var<br/>
    <span class="keywordsign">|</span> <span class="constructor">GraphTerm</span> <span class="keyword">of</span> graph_term<br/>
  <span class="keyword">and</span> path_one_in_prop_set =<br/>
    <span class="constructor">Rdf_sparql_types</span>.path_one_in_prop_set =<br/>
      <span class="constructor">PathOneInIri</span> <span class="keyword">of</span> iri<br/>
    <span class="keywordsign">|</span> <span class="constructor">PathOneInA</span><br/>
    <span class="keywordsign">|</span> <span class="constructor">PathOneInNotIri</span> <span class="keyword">of</span> iri<br/>
    <span class="keywordsign">|</span> <span class="constructor">PathOneInNotA</span><br/>
  <span class="keyword">and</span> path_primary =<br/>
    <span class="constructor">Rdf_sparql_types</span>.path_primary =<br/>
      <span class="constructor">PathIri</span> <span class="keyword">of</span> iri<br/>
    <span class="keywordsign">|</span> <span class="constructor">PathA</span><br/>
    <span class="keywordsign">|</span> <span class="constructor">PathNegPropSet</span> <span class="keyword">of</span> path_one_in_prop_set list<br/>
    <span class="keywordsign">|</span> <span class="constructor">Path</span> <span class="keyword">of</span> path<br/>
  <span class="keyword">and</span> path_elt =<br/>
    <span class="constructor">Rdf_sparql_types</span>.path_elt = {<br/>
    pelt_loc : loc;<br/>
    pelt_primary : path_primary;<br/>
    pelt_mod : path_mod option;<br/>
  }<br/>
  <span class="keyword">and</span> path_elt_or_inverse =<br/>
    <span class="constructor">Rdf_sparql_types</span>.path_elt_or_inverse =<br/>
      <span class="constructor">Elt</span> <span class="keyword">of</span> path_elt<br/>
    <span class="keywordsign">|</span> <span class="constructor">Inv</span> <span class="keyword">of</span> path_elt<br/>
  <span class="keyword">and</span> path_sequence = path_elt_or_inverse list<br/>
  <span class="keyword">and</span> path = path_sequence list<br/>
  <span class="keyword">and</span> verb =<br/>
    <span class="constructor">Rdf_sparql_types</span>.verb =<br/>
      <span class="constructor">VerbPath</span> <span class="keyword">of</span> path<br/>
    <span class="keywordsign">|</span> <span class="constructor">VerbVar</span> <span class="keyword">of</span> var<br/>
    <span class="keywordsign">|</span> <span class="constructor">VerbIri</span> <span class="keyword">of</span> iri<br/>
    <span class="keywordsign">|</span> <span class="constructor">VerbA</span><br/>
  <span class="keyword">and</span> triples_node =<br/>
    <span class="constructor">Rdf_sparql_types</span>.triples_node =<br/>
      <span class="constructor">TNodeCollection</span> <span class="keyword">of</span> graph_node list<br/>
    <span class="keywordsign">|</span> <span class="constructor">TNodeBlank</span> <span class="keyword">of</span> prop_object_list list<br/>
  <span class="keyword">and</span> graph_node =<br/>
    <span class="constructor">Rdf_sparql_types</span>.graph_node =<br/>
      <span class="constructor">GraphNodeVT</span> <span class="keyword">of</span> var_or_term<br/>
    <span class="keywordsign">|</span> <span class="constructor">GraphNodeTriples</span> <span class="keyword">of</span> triples_node<br/>
  <span class="keyword">and</span> object_ = graph_node<br/>
  <span class="keyword">and</span> prop_object_list =<br/>
    <span class="constructor">Rdf_sparql_types</span>.prop_object_list = {<br/>
    propol_loc : loc;<br/>
    propol_verb : verb;<br/>
    propol_objects : object_ list;<br/>
  }<br/>
  <span class="keyword">and</span> triples_block =<br/>
    <span class="constructor">Rdf_sparql_types</span>.triples_block = {<br/>
    triples_loc : loc;<br/>
    triples : triples_same_subject list;<br/>
  }<br/>
  <span class="keyword">and</span> triples_same_subject =<br/>
    <span class="constructor">Rdf_sparql_types</span>.triples_same_subject =<br/>
      <span class="constructor">TriplesVar</span> <span class="keyword">of</span> var_or_term * prop_object_list list<br/>
    <span class="keywordsign">|</span> <span class="constructor">TriplesNode</span> <span class="keyword">of</span> triples_node * prop_object_list list<br/>
  <span class="keyword">and</span> ggp_sub =<br/>
    <span class="constructor">Rdf_sparql_types</span>.ggp_sub = {<br/>
    ggp_sub_loc : loc;<br/>
    ggp_sub_elts : graph_pattern_elt list;<br/>
  }<br/>
  <span class="keyword">and</span> group_graph_pattern =<br/>
    <span class="constructor">Rdf_sparql_types</span>.group_graph_pattern =<br/>
      <span class="constructor">SubSelect</span> <span class="keyword">of</span> sub_select<br/>
    <span class="keywordsign">|</span> <span class="constructor">GGPSub</span> <span class="keyword">of</span> ggp_sub<br/>
  <span class="keyword">and</span> sub_select =<br/>
    <span class="constructor">Rdf_sparql_types</span>.sub_select = {<br/>
    subsel_loc : loc;<br/>
    subsel_select : select_clause;<br/>
    subsel_where : group_graph_pattern;<br/>
    subsel_modifier : solution_modifier;<br/>
    subsel_values : values_clause;<br/>
  }<br/>
  <span class="keyword">type</span> select_query =<br/>
    <span class="constructor">Rdf_sparql_types</span>.select_query = {<br/>
    select_select : select_clause;<br/>
    select_dataset : dataset_clause list;<br/>
    select_where : group_graph_pattern;<br/>
    select_modifier : solution_modifier;<br/>
  }<br/>
  <span class="keyword">type</span> triples_template = triples_same_subject list<br/>
  <span class="keyword">type</span> construct_template = triples_template<br/>
  <span class="keyword">type</span> construct_where =<br/>
    <span class="constructor">Rdf_sparql_types</span>.construct_where =<br/>
      <span class="constructor">Constr_ggp</span> <span class="keyword">of</span> group_graph_pattern<br/>
    <span class="keywordsign">|</span> <span class="constructor">Constr_template</span> <span class="keyword">of</span> triples_template<br/>
  <span class="keyword">type</span> construct_query =<br/>
    <span class="constructor">Rdf_sparql_types</span>.construct_query = {<br/>
    constr_template : construct_template option;<br/>
    constr_dataset : dataset_clause list;<br/>
    constr_where : construct_where;<br/>
    constr_modifier : solution_modifier;<br/>
  }<br/>
  <span class="keyword">type</span> describe_query =<br/>
    <span class="constructor">Rdf_sparql_types</span>.describe_query = {<br/>
    desc_sel : var_or_iri list;<br/>
    desc_dataset : dataset_clause list;<br/>
    desc_where : group_graph_pattern option;<br/>
    desc_modifier : solution_modifier;<br/>
  }<br/>
  <span class="keyword">type</span> ask_query =<br/>
    <span class="constructor">Rdf_sparql_types</span>.ask_query = {<br/>
    ask_dataset : dataset_clause list;<br/>
    ask_where : group_graph_pattern;<br/>
    ask_modifier : solution_modifier;<br/>
  }<br/>
  <span class="keyword">type</span> query_kind =<br/>
    <span class="constructor">Rdf_sparql_types</span>.query_kind =<br/>
      <span class="constructor">Select</span> <span class="keyword">of</span> select_query<br/>
    <span class="keywordsign">|</span> <span class="constructor">Construct</span> <span class="keyword">of</span> construct_query<br/>
    <span class="keywordsign">|</span> <span class="constructor">Describe</span> <span class="keyword">of</span> describe_query<br/>
    <span class="keywordsign">|</span> <span class="constructor">Ask</span> <span class="keyword">of</span> ask_query<br/>
  <span class="keyword">type</span> query =<br/>
    <span class="constructor">Rdf_sparql_types</span>.query = {<br/>
    q_prolog : query_prolog;<br/>
    q_kind : query_kind;<br/>
    q_values : values_clause;<br/>
  }<br/>
  <span class="keyword">module</span> <span class="constructor">VarSet</span> :<br/>
    <span class="keyword">sig</span><br/>
      <span class="keyword">type</span> elt = var<br/>
      <span class="keyword">type</span> t = <span class="constructor">Rdf_sparql_types</span>.<span class="constructor">VarSet</span>.t<br/>
      <span class="keyword">val</span> empty : t<br/>
      <span class="keyword">val</span> is_empty : t <span class="keywordsign">-&gt;</span> bool<br/>
      <span class="keyword">val</span> mem : elt <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> bool<br/>
      <span class="keyword">val</span> add : elt <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> t<br/>
      <span class="keyword">val</span> singleton : elt <span class="keywordsign">-&gt;</span> t<br/>
      <span class="keyword">val</span> remove : elt <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> t<br/>
      <span class="keyword">val</span> union : t <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> t<br/>
      <span class="keyword">val</span> inter : t <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> t<br/>
      <span class="keyword">val</span> diff : t <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> t<br/>
      <span class="keyword">val</span> compare : t <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> int<br/>
      <span class="keyword">val</span> equal : t <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> bool<br/>
      <span class="keyword">val</span> subset : t <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> bool<br/>
      <span class="keyword">val</span> iter : (elt <span class="keywordsign">-&gt;</span> unit) <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> unit<br/>
      <span class="keyword">val</span> fold : (elt <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a) <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a<br/>
      <span class="keyword">val</span> for_all : (elt <span class="keywordsign">-&gt;</span> bool) <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> bool<br/>
      <span class="keyword">val</span> exists : (elt <span class="keywordsign">-&gt;</span> bool) <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> bool<br/>
      <span class="keyword">val</span> filter : (elt <span class="keywordsign">-&gt;</span> bool) <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> t<br/>
      <span class="keyword">val</span> partition : (elt <span class="keywordsign">-&gt;</span> bool) <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> t * t<br/>
      <span class="keyword">val</span> cardinal : t <span class="keywordsign">-&gt;</span> int<br/>
      <span class="keyword">val</span> elements : t <span class="keywordsign">-&gt;</span> elt list<br/>
      <span class="keyword">val</span> min_elt : t <span class="keywordsign">-&gt;</span> elt<br/>
      <span class="keyword">val</span> max_elt : t <span class="keywordsign">-&gt;</span> elt<br/>
      <span class="keyword">val</span> choose : t <span class="keywordsign">-&gt;</span> elt<br/>
      <span class="keyword">val</span> split : elt <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> t * bool * t<br/>
      <span class="keyword">val</span> find : elt <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> elt<br/>
    <span class="keyword">end</span><br/>
<span class="keyword">end</span></code></div>


</div>

<footer id="bottombar">
</footer>
<script src="http://zoggy.github.io/ocaml-rdf/jquery.js" type="text/javascript">_</script>
<script src="http://zoggy.github.io/ocaml-rdf/bootstrap-collapse.js" type="text/javascript">_</script>

</body>
</html>